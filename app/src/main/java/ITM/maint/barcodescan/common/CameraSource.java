/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ITM.maint.barcodescan.common;

import android.Manifest;
import android.animation.ValueAnimator;
import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.ImageFormat;
import android.graphics.Matrix;
import android.graphics.Point;
import android.graphics.RectF;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.media.Image;
import android.media.ImageReader;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import android.util.Size;
import android.util.SparseIntArray;
import android.view.Surface;
import android.view.SurfaceHolder;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;

import com.google.android.gms.tasks.Task;
import com.google.firebase.ml.vision.FirebaseVision;
import com.google.firebase.ml.vision.barcode.FirebaseVisionBarcode;
import com.google.firebase.ml.vision.barcode.FirebaseVisionBarcodeDetector;
import com.google.firebase.ml.vision.barcode.FirebaseVisionBarcodeDetectorOptions;
import com.google.firebase.ml.vision.common.FirebaseVisionImage;
import com.google.firebase.ml.vision.common.FirebaseVisionImageMetadata;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

import ITM.maint.barcodescan.BarcodeConfirmingGraphic;
import ITM.maint.barcodescan.BarcodeLoadingGraphic;
import ITM.maint.barcodescan.BarcodeReticleGraphic;
import ITM.maint.barcodescan.R;
import ITM.maint.barcodescan.common.preferences.PreferenceUtils;

/**
 * Manages the camera and allows UI updates on top of it (e.g. overlaying extra Graphics). This
 * receives preview frames from the camera at a specified rate, sends those frames to detector as
 * fast as it is able to process.
 *
 * <p>This camera source makes a best effort to manage processing on preview frames as fast as
 * possible, while at the same time minimizing lag. As such, frames may be dropped if the detector
 * is unable to keep up with the rate of frames generated by the camera.
 */
public class CameraSource {

  public static final int CAMERA_FACING_BACK = CameraCharacteristics.LENS_FACING_BACK;

  private static final String TAG = "CameraSource";

  private static final int IMAGE_FORMAT = ImageFormat.NV21;
  private static final int MIN_CAMERA_PREVIEW_WIDTH = 400;
  private static final int MAX_CAMERA_PREVIEW_WIDTH = 1920;
  private static final int MAX_CAMERA_PREVIEW_HEIGHT = 1080;
  private static final int DEFAULT_REQUESTED_CAMERA_PREVIEW_WIDTH = 640;
  private static final int DEFAULT_REQUESTED_CAMERA_PREVIEW_HEIGHT = 360;
  private static final float REQUESTED_CAMERA_FPS = 30.0f;

  private static final SparseIntArray ORIENTATIONS = new SparseIntArray();
  static {
    ORIENTATIONS.append(Surface.ROTATION_0, 90);
    ORIENTATIONS.append(Surface.ROTATION_90, 0);
    ORIENTATIONS.append(Surface.ROTATION_180, 270);
    ORIENTATIONS.append(Surface.ROTATION_270, 180);
  }

  private CameraSourcePreview previewView;
  private CameraDevice camera;
  private String cameraID;
  private CaptureRequest.Builder previewRequestBuilder;
  private CaptureRequest previewRequest;
  private CameraCaptureSession cameraCaptureSession;

  @FirebaseVisionImageMetadata.Rotation
  private int rotation;
  private Size previewSize;

  private final Semaphore processorLock = new Semaphore(1);
  private VisionImageProcessor frameProcessor;

  private final Map<byte[], ByteBuffer> bytesToByteBuffer = new IdentityHashMap<>();

  private final Context context;
  private final GraphicOverlay graphicOverlay;
  private FirebaseVisionBarcodeDetector barcodeDetector;
  private final CameraReticleAnimator cameraReticleAnimator;
  private WorkflowModel workflowModel;
  private ImageReader imageReader;
  private Surface surface;

  private Handler backgroundHandler;
  private HandlerThread backgroundThread;

  private final CameraCaptureSession.CaptureCallback captureCallback
          = new CameraCaptureSession.CaptureCallback() {

    private void process(CaptureResult result) {
        int name;
        name = 0;
    }

    @Override
    public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                   @NonNull CaptureRequest request,
                                   @NonNull TotalCaptureResult result) {
      process(result);
    }

  };

  private final CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() {

    @Override
    public void onOpened(@NonNull CameraDevice cameraDevice) {
      release();
      camera = cameraDevice;
      previewView.createCameraPreviewSession(camera, surface);
      startCameraSession(surface);
    }

    @Override
    public void onDisconnected(@NonNull CameraDevice cameraDevice) {
      release();
      cameraDevice.close();
      camera = null;
    }

    @Override
    public void onError(@NonNull CameraDevice cameraDevice, int error) {
      release();
      cameraDevice.close();
      camera = null;
    }

  };


  private final ImageReader.OnImageAvailableListener onImageAvailableListener
          = new ImageReader.OnImageAvailableListener() {

    @Override
    public void onImageAvailable(ImageReader reader) {
      Image image = reader.acquireNextImage();
      FirebaseVisionBarcodeDetectorOptions options =
              new FirebaseVisionBarcodeDetectorOptions.Builder()
                      .setBarcodeFormats(FirebaseVisionBarcode.FORMAT_ALL_FORMATS)
                      .build();
      barcodeDetector = FirebaseVision.getInstance().getVisionBarcodeDetector(options);

      FirebaseVisionImage visionImage = FirebaseVisionImage.fromMediaImage(image, ImageFormat.YUV_420_888 );

      Task<List<FirebaseVisionBarcode>> task;
      task = barcodeDetector.detectInImage(visionImage);
      task.addOnSuccessListener( barcodes -> {
        if (!barcodes.isEmpty()) {
          FirebaseVisionBarcode barcodeInCenter = null;
          for (FirebaseVisionBarcode barcode : barcodes) {
            RectF box = graphicOverlay.translateRect(barcode.getBoundingBox());
            if (box.contains(graphicOverlay.getWidth() / 2f, graphicOverlay.getHeight() / 2f)) {
              barcodeInCenter = barcode;
              break;
            }

            graphicOverlay.clear();
            if (barcodeInCenter == null) {
              cameraReticleAnimator.start();
              graphicOverlay.add(new BarcodeReticleGraphic(graphicOverlay, cameraReticleAnimator));
              workflowModel.setWorkflowState(WorkflowModel.WorkflowState.DETECTING);
            } else {
              cameraReticleAnimator.cancel();
              float sizeProgress =
                      PreferenceUtils.getProgressToMeetBarcodeSizeRequirement(graphicOverlay, barcodeInCenter);
              if (sizeProgress < 1) {
                // Barcode in the camera view is too small, so prompt user to move camera closer.
                graphicOverlay.add(new BarcodeConfirmingGraphic(graphicOverlay, barcodeInCenter));
                workflowModel.setWorkflowState(WorkflowModel.WorkflowState.CONFIRMING);
              } else {
                // Barcode size in the camera view is sufficient.
                if (PreferenceUtils.shouldDelayLoadingBarcodeResult(graphicOverlay.getContext())) {
                  ValueAnimator loadingAnimator = createLoadingAnimator(graphicOverlay, barcodeInCenter);
                  loadingAnimator.start();
                  graphicOverlay.add(new BarcodeLoadingGraphic(graphicOverlay, loadingAnimator));
                  workflowModel.setWorkflowState(WorkflowModel.WorkflowState.SEARCHING);
                } else {
                  workflowModel.setWorkflowState(WorkflowModel.WorkflowState.DETECTED);
                  workflowModel.detectedBarcode.setValue(barcodeInCenter);
                }
              }
            }
            graphicOverlay.invalidate();

          }
        }
      });
    }

  };


  public CameraSource(GraphicOverlay graphicOverlay, WorkflowModel workFlowModel) {
    this.context = graphicOverlay.getContext();
    this.graphicOverlay = graphicOverlay;
    previewView = ((Activity) this.context).findViewById(R.id.camera_preview);
    previewView.attachCamera(this);
    this.cameraReticleAnimator = new CameraReticleAnimator(graphicOverlay);
    this.workflowModel = workFlowModel;
  }

  public void start() {
    if (previewView.isSurfaceAvailable()){
      openCamera(getPreviewSize().getWidth(), getPreviewSize().getHeight());
    }
  }

  public void stop() {
    closeCamera();
    stopBackgroundThread();
  }

  public void release() {
    processorLock.release();
  }

  public Handler getBackgroundHandler() {
    return backgroundHandler;
  }

  public ImageReader getImageReader() {
    return imageReader;
  }

  public void updateFlashMode(String flashMode) {
    //Parameters parameters = camera.getParameters();
    //parameters.setFlashMode(flashMode);
    //camera.setParameters(parameters);
  }

  private void closeCamera() {
    try {
      processorLock.acquire();
      if (null != camera) {
        camera.close();
        camera = null;
      }
      if (null != imageReader) {
        imageReader.close();
        imageReader = null;
      }
      if (null != cameraCaptureSession) {
        cameraCaptureSession.close();
        cameraCaptureSession = null;
      }
      if (null != cameraCaptureSession) {
        cameraCaptureSession.close();
        cameraCaptureSession = null;
      }

    } catch (InterruptedException e) {
      throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
    } finally {
      processorLock.release();
    }

  }

  public void openCamera(int width, int height) {

    setUpCameraOutputs(width, height);
    configureTransform(width, height);

    CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
    try {
      if (!processorLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
        throw new RuntimeException("Time out waiting to lock camera opening.");
      }
      if (ActivityCompat.checkSelfPermission(context, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
        return;
      }
      startBackgroundThread();
      manager.openCamera(cameraID, stateCallback, backgroundHandler);
    } catch (CameraAccessException e) {
      e.printStackTrace();
    } catch (InterruptedException e) {
      throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
    }
  }

  /** Returns the preview size that is currently in use by the underlying camera. */
  Size getPreviewSize() {
    return previewSize;
  }

  static class CompareSizesByArea implements Comparator<Size> {

    @Override
    public int compare(Size lhs, Size rhs) {
      return Long.signum((long) lhs.getWidth() * lhs.getHeight() -
              (long) rhs.getWidth() * rhs.getHeight());
    }

    @Override
    public Comparator<Size> reversed() {
      return null;
    }
  }

  private static Size chooseOptimalSize(Size[] choices, int textureViewWidth,
                                        int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio) {
    List<Size> bigEnough = new ArrayList<>();
    List<Size> notBigEnough = new ArrayList<>();
    int w = aspectRatio.getWidth();
    int h = aspectRatio.getHeight();
    for (Size option : choices) {
      if (option.getWidth() <= maxWidth && option.getHeight() <= maxHeight &&
              option.getHeight() == option.getWidth() * h / w) {
        if (option.getWidth() >= textureViewWidth &&
                option.getHeight() >= textureViewHeight) {
          bigEnough.add(option);
        } else {
          notBigEnough.add(option);
        }
      }
    }

    if (bigEnough.size() > 0) {
      return Collections.min(bigEnough, new CompareSizesByArea());
    } else if (notBigEnough.size() > 0) {
      return Collections.max(notBigEnough, new CompareSizesByArea());
    } else {
      return choices[0];
    }
  }

  private void setUpCameraOutputs(int width, int height) {
    CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
    try {
      for (String ID : manager.getCameraIdList()) {
        CameraCharacteristics characteristics
                = manager.getCameraCharacteristics(ID);

        Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
        if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {
          continue;
        }

        cameraID = ID;

        StreamConfigurationMap map = characteristics.get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        if (map == null) {
          continue;
        }

        List imageSizes = Arrays.asList(map.getOutputSizes(ImageFormat.JPEG));
        Size largest = Collections.max(imageSizes, new CompareSizesByArea());

        imageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(),
                ImageFormat.JPEG, /*maxImages*/2);
        imageReader.setOnImageAvailableListener(
                onImageAvailableListener, backgroundHandler);

        int displayRotation = ((Activity)context).getWindowManager().getDefaultDisplay().getRotation();
        rotation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
        boolean swappedDimensions = false;
        switch (displayRotation) {
          case Surface.ROTATION_0:
          case Surface.ROTATION_180:
            if (rotation == 90 || rotation == 270) {
              swappedDimensions = true;
            }
            break;
          case Surface.ROTATION_90:
          case Surface.ROTATION_270:
            if (rotation == 0 || rotation == 180) {
              swappedDimensions = true;
            }
            break;
        }

        Point displaySize = new Point();
        ((Activity)context).getWindowManager().getDefaultDisplay().getSize(displaySize);
        int rotatedPreviewWidth = width;
        int rotatedPreviewHeight = height;
        int maxPreviewWidth = displaySize.x;
        int maxPreviewHeight = displaySize.y;

        if (swappedDimensions) {
          rotatedPreviewWidth = height;
          rotatedPreviewHeight = width;
          maxPreviewWidth = displaySize.y;
          maxPreviewHeight = displaySize.x;
        }

        if (maxPreviewWidth > MAX_CAMERA_PREVIEW_WIDTH) {
          maxPreviewWidth = MAX_CAMERA_PREVIEW_WIDTH;
        }

        if (maxPreviewHeight > MAX_CAMERA_PREVIEW_HEIGHT) {
          maxPreviewHeight = MAX_CAMERA_PREVIEW_HEIGHT;
        }

        previewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture.class),
                rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                maxPreviewHeight, largest);

        int orientation = context.getResources().getConfiguration().orientation;
        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
          previewView.setAspectRatio(
                  previewView.getWidth(), previewSize.getHeight());
        } else {
          previewView.setAspectRatio(
                  previewSize.getHeight(), previewSize.getWidth());
        }

        return;
      }
    } catch (CameraAccessException e) {
      e.printStackTrace();
    } catch (NullPointerException e) {
    }
  }


  private void configureTransform(int viewWidth, int viewHeight) {
    Activity activity = (Activity) context;
    if (null == previewView || null == previewSize || null == activity) {
      return;
    }
    int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
    Matrix matrix = new Matrix();
    RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);
    RectF bufferRect = new RectF(0, 0, previewSize.getHeight(), previewSize.getWidth());
    float centerX = viewRect.centerX();
    float centerY = viewRect.centerY();
    if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {
      bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());
      matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
      float scale = Math.max(
              (float) viewHeight / previewSize.getHeight(),
              (float) viewWidth / previewSize.getWidth());
      matrix.postScale(scale, scale, centerX, centerY);
      matrix.postRotate(90 * (rotation - 2), centerX, centerY);
    } else if (Surface.ROTATION_180 == rotation) {
      matrix.postRotate(180, centerX, centerY);
    }
    previewView.setTransform(matrix);
  }

  public void startCameraSession(Surface surface){
    try {
      previewRequestBuilder = camera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
      previewRequestBuilder.addTarget(surface);
      camera.createCaptureSession(Arrays.asList(surface),
              new CameraCaptureSession.StateCallback() {

                @Override
                public void onConfigured(@NonNull CameraCaptureSession captureSession) {
                  if (null == camera) {
                    return;
                  }

                  cameraCaptureSession = captureSession;
                  try {
                    previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
                            CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

                    previewRequest = previewRequestBuilder.build();
                    cameraCaptureSession.setRepeatingRequest(previewRequest,
                            captureCallback, backgroundHandler);
                  } catch (CameraAccessException e) {
                    e.printStackTrace();
                  }
                }

                @Override
                public void onConfigureFailed(
                        @NonNull CameraCaptureSession cameraCaptureSession) {
                }
              }, null
      );

    } catch (CameraAccessException e) {
      e.printStackTrace();
    }
  }

  /**
   * Starts a background thread and its {@link Handler}.
   */
  private void startBackgroundThread() {
    backgroundThread = new HandlerThread("CameraBackground");
    backgroundThread.start();
    backgroundHandler = new Handler(backgroundThread.getLooper());
  }

  /**
   * Stops the background thread and its {@link Handler}.
   */
  private void stopBackgroundThread() {
    if (backgroundThread != null) {
      backgroundThread.quitSafely();
      try {
        backgroundThread.join();
        backgroundThread = null;
        backgroundHandler = null;
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }


  private ValueAnimator createLoadingAnimator(
          GraphicOverlay graphicOverlay, FirebaseVisionBarcode barcode) {
    float endProgress = 1.1f;
    ValueAnimator loadingAnimator = ValueAnimator.ofFloat(0f, endProgress);
    loadingAnimator.setDuration(2000);
    loadingAnimator.addUpdateListener(
            animation -> {
              if (Float.compare((float) loadingAnimator.getAnimatedValue(), endProgress) >= 0) {
                graphicOverlay.clear();
              } else {
                graphicOverlay.invalidate();
              }
            });
    return loadingAnimator;
  }

}
